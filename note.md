基于v1版本, DefaultBeanFactory做了太多处理XML相关的事情，这违反了单一职责原则（SRP）。

职责： 是引起变化的原因  
	- 如果有多余一个的动机去改变一个类，这个类就具有多于一个职责
	- 把多个职责耦合在一起，一个变化可能会削弱或者抑制这个类完成其他职责的能力
SRP：对于一个类而言，应该仅有一个引起他变化的原因。  
### 改进
1. 创建一个XMLBeanDefinitionReader类来处理xml文件，在BeanFactory里面添加一个registerBeanDefinition方法，XMLBeanDefinitionReader持有一个BeanFactory的对象，每读出一个bean的定义，就调用registerBeanDefinition方法注册到BeanFactory中  
缺点： BeanDefinition是我们实现的时候的一个内部概念，不应该被client端感知，所以不应该出现在BeanFactory中，所以getBeanDefinition不应该出现。BeanFactory是让client去调用的，registerBeanDefinition对外暴露了修改内部数据结构的能力  
2. 在上面的基础上，新加一个BeanDefinitionRegistry的接口，将registerBeanDefinition和getBeanDefinition挪到其中，XMLBeanDefinitionReader不再直接持有BeanFactory，而是持有BeanDefinitionRegistry对象，实现时，DefaultBeanFactory同时实现BeanDefinitionRegistry和BeanFactory连个接口。
优点：接口最小化，XMLBeanDefinitionReader只知道BeanDefinitionRegistry，Client只知道BeanFactory。

BeanDefinitionRegistry放在了support中，因为这个是和实现相关的，不用向Client端暴露

测试用例也需要被维护

我们在使用的时候用的是ApplicationContext,
改进：
在上一层的基础上，让ApplicationContext继承BeanFactory，实现类内部持有一个DefaultBeanFactory的实例，delegate getBean()方法

问题：基于现在的模式，在new DefaultBeanFactory的时候，引用类型必须用DefaultBeanFactory而不是父类BeanFactory，因为XMLBeanDefinitionReader的构造参数是BeanDefinitionRegistry


除了ClassPathXmlApplicationContext之外还会有其他的类型ApplicationContext，他们有很多共同之处，比如都是从xml中读取bean定义，不同之处在于他们获取xml的方式不同，但是他们获取xml之后都要变成inputstream给dom4j去解析，把这个共同之处提取出来就是Resource，Resource接口提供一个getInputStream

这些不同的ApplicationContext只是在加载resource的地方有些不同，所以可以用模板方法模式来改造，在父类里面添加一个getResourceByPath的抽象方法。